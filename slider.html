<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>Maptest</title>

	<link rel="stylesheet" href="./leaflet/leaflet.css" />
	<script src="./leaflet/leaflet.js"></script>
	<script src="./jquery.min.js"></script>
	<script src="./jquery-ui.min.js"></script>
	<script src="./us_states.js"></script>
	<script src="./us_states_2_variation.js"></script>
	<style>

		.map {
			height: 450px;
			position: absolute;
			top: 1px;
			left: 1px;
		}
		#map-left {
			width: 900px; /* Workaround, see GeoJSON & map data loading... */
			z-index: 30;
		}
		#map-mid {
			width: 900px; /* Also part of the workaround. */
			z-index: 20;
		}
		#map-right {
			width: 900px;
			z-index: 10;
		}
		#container {
			position: relative;
			border: 1px solid gray;
			display: table;
			z-index: 50;
			width: 900px;
			height: 450px;
			border-radius: 2px 2px 0px 0px;
			margin: 0 auto;
		}
		h1, p{
			text-align: center;
		}

		#dragwrapper-left{
			position: absolute;
			left: 285px;
			z-index: 80;
		}
		#dragwrapper-right{
			position: absolute;
			left: 585px;
			z-index: 80;
		}
		#drag-left{
			position: absolute;
			width: 2px;
			background: rgb(136, 136, 136) none repeat scroll;
			height: 450px;
			left: 15px;
			max-width: 2px;
		}
		#drag-right{
			position: absolute;
			width: 2px;
			background: rgb(136, 136, 136) none repeat scroll;
			height: 450px;
			left: 15px;
			max-width: 2px;
		}
		#draghandle-left{
			position: relative;
			cursor: pointer;
			z-index: 100;
			left: -15px;
		}
		#draghandle-right{
			position: relative;
			cursor: pointer;
			z-index: 100;
			left: -15px;
			top: 426px;
		}
		#constraint{
			position: absolute;
			top: 1px;
			left: 1px;
			height: 100%;
			width:870px;
		}
		#infobox {
			border: 1px solid gray;
			border-top: 0px;
			display: table;
			width: 900px;
			border-radius: 0px 0px 2px 2px;
			margin: 0 auto;
		}
	</style>

</head>

<body>
	<h1>Comparison Slider</h1>
	<div id="container">
		<div id="constraint"></div>
		<div id="dragwrapper-left">
			<div id="drag-left">
				<img id="draghandle-left" src="./sliders.png">
			</div>
		</div>
		<div id="dragwrapper-right">
			<div id="drag-right">
				<img id="draghandle-right" src="./sliders.png">
			</div></div>
		<div id="map-left" class="map"></div>
		<div id="map-mid" class="map"></div>
		<div id="map-right" class="map"></div>
	</div>
	<div id="infobox">
		<p id="infotext">Hover over choropleth shapes to show more information.</p>
	</div>
	<p>&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors</p>
	<script>

		// set up 3 maps
		var leftmap = L.map('map-left', {center: [51.505, -0.09], zoom: 13, zoomAnimation: false, attributionControl: false, zoomControl: false});
		var midmap = L.map('map-mid', {center: [51.505, -0.09], zoom: 13, zoomAnimation: false, attributionControl: false, zoomControl: false});
		var rightmap = L.map('map-right', {center: [51.505, -0.09], zoom: 13, zoomAnimation: false, attributionControl: false, zoomControl: false});

		var basemap = 'http://{s}.tile.osm.org/{z}/{x}/{y}.png';
		var basemap_options = {
				maxZoom: 18
		};

		L.tileLayer(basemap, basemap_options).addTo(leftmap);
		L.tileLayer(basemap, basemap_options).addTo(midmap);
		L.tileLayer(basemap, basemap_options).addTo(rightmap);

		// avoid endless recursion when synchronizing the map
		var recursing = 0;

		function getCenterDistance(a, b) {
			return (b.getSize().x/2) - (a.getSize().x/2);
		}

		function syncMaps(source, target) {
			if(recursing > 3) {
				recursing = 0;
				return;
			}

			recursing += 1;

			let offset = getCenterDistance(source, target);

			let zoom = source.getZoom();
			let center = source.getCenter();
			let pixels = source.latLngToLayerPoint(center);
			pixels.x += offset;

			target.setView(source.layerPointToLatLng(pixels), source.getZoom(), { animate: false });
		}

		// register synchronization function
		leftmap.on('move', function() {
			syncMaps(leftmap, rightmap);
			syncMaps(leftmap, midmap);
		});

		midmap.on('move', function() {
			syncMaps(midmap, leftmap);
			syncMaps(midmap, rightmap);
		});

		rightmap.on('move', function() {
			syncMaps(rightmap, leftmap);
			syncMaps(rightmap, midmap);
		});

		// create draggable handles
		$('#dragwrapper-left').draggable({ containment:$('#constraint'),drag:$('#drag-left'),stop:$('#drag-left'), axis: "x" });
		$('#dragwrapper-right').draggable({ containment:$('#constraint'),drag:$('#drag-right'),stop:$('#drag-right'), axis: "x"});
		
		$('#dragwrapper-left').on('drag', function() {
			$('#map-left').width( $('#dragwrapper-left').position().left + 16);
		});

		$('#dragwrapper-right').on('drag', function() {
			$('#map-mid').width( $('#dragwrapper-right').position().left + 16);
		});

		// workaround for draggable bug
		var workaround_yl = $('#dragwrapper-left').position().top + 1;
		var workaround_yr = $('#dragwrapper-left').position().top + 1;

		$('#dragwrapper-left').on('dragstop', function() {
			$("#dragwrapper-left").css({top: workaround_yl+'px'});
		});

		$('#dragwrapper-right').on('dragstop', function() {
			$("#dragwrapper-right").css({top: workaround_yr+'px'});
		});

		// make sure both datasets have the same size
		if(statesData.features.size != statesData2.features.size) {
			alert("Error: datasets can't be compared");
			exit;
		}

		// the functions from the tutorial to color and style the maps
		function getColor(d) {
			return d > 1000 ? '#800026' :
				d > 500  ? '#BD0026' :
				d > 200  ? '#E31A1C' :
				d > 100  ? '#FC4E2A' :
				d > 50   ? '#FD8D3C' :
				d > 20   ? '#FEB24C' :
				d > 10   ? '#FED976' :
				'#FFEDA0';
		}

		function style(feature) {
			return {
				weight: 2,
				opacity: 1,
				color: 'white',
				dashArray: '3',
				fillOpacity: 1,
				fillColor: getColor(feature.properties.density)
			};
		}

		function resetInfo() {
			$('#infotext')[0].innerHTML = "Hover over choropleth shapes to show more information.";
		}

		function setInfo(properties) {
			if(properties.density === undefined) { // in this case it's midmap
				$('#infotext')[0].innerHTML = properties.name + ": " + properties.density_left + " ‚üº " +
				properties.density_right + " (" + (properties.density_diff < 0 ? properties.density_diff : ("+" + properties.density_diff)) + ")";
			}
			else { // otherwise it's right or left
				$('#infotext')[0].innerHTML = properties.name + ": " + properties.density;
			} 
		}

		function highlightFeature(e) {
			var layer = e.target;

			layer.setStyle({
				weight: 3,
				color: '#55DDFF',
				dashArray: '',
				fillOpacity: 1
			});

			if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
				layer.bringToFront();
			}

			setInfo(layer.feature.properties);

		}

		function resetHighlightR(e) {
			geojson_right.resetStyle(e.target);
			resetInfo();
		}
		function resetHighlightL(e) {
			geojson_left.resetStyle(e.target);
			resetInfo();
		}

		function onEachFeatureR(feature, layer) {
			layer.on({
				mouseover: highlightFeature,
				mouseout: resetHighlightR
			});
		}

		function onEachFeatureL(feature, layer) {
			layer.on({
				mouseover: highlightFeature,
				mouseout: resetHighlightL
			});
		}

		// load data into the maps
		var geojson_left = L.geoJson(statesData, {
			style: style,
			onEachFeature: onEachFeatureL
		}).addTo(leftmap);
		var geojson_right = L.geoJson(statesData2, {
			style: style,
			onEachFeature: onEachFeatureR
		}).addTo(rightmap);

		// creating the difference map
		var diffData = {
			"type" : "FeatureCollection",
			"features" : []
		};
		for (let dataset = 0; dataset < statesData.features.length; dataset++) {
			let ldata = statesData.features[dataset];
			let rdata = statesData2.features[dataset];

			let newdata = {
				type: "Feature",
				id: "" + (dataset + 1) + "",
				properties: {
					name: ldata.properties.name,
					density_diff: rdata.properties.density - ldata.properties.density,
					density_left: ldata.properties.density,
					density_right: rdata.properties.density
				},
				geometry: ldata.geometry
			};
			diffData.features.push(newdata);
		}

		function getColorDensity(d) {
			return d > 0 ? '#80CC80' :
				d == 0  ? '#808080' :
				'#CC8080';
		}

		function styleDifference(feature) {
			return {
				weight: 2,
				opacity: 1,
				color: 'white',
				dashArray: '3',
				fillOpacity: 1,
				fillColor: getColorDensity(feature.properties.density_diff)
			};
		}

		function resetHighlightM(e) {
			geojson_mid.resetStyle(e.target);
			resetInfo();
		}

		function onEachFeatureM(feature, layer) {
			layer.on({
				mouseover: highlightFeature,
				mouseout: resetHighlightM
			});
		}

		var geojson_mid = L.geoJson(diffData, {
			style: styleDifference,
			onEachFeature: onEachFeatureM
		}).addTo(midmap);

		// workaround reset for shape offset bug
		$('#map-left').width(300);
		$('#map-mid').width(600);

		// call syncMaps to synchronize at the beginning
		rightmap.setView([37.8, -96], 4);
		syncMaps(rightmap, leftmap);
		syncMaps(rightmap, midmap);
	</script>
</body>

</html>